---
title: 高斯消元
date: 2020-02-06 23:08:29
categories: 
	- 数学
tags: 
	- 数论
	- 矩阵
	- 线性方程组
	- 高斯消元
---

## 线性方程组和增广矩阵

对于一个含n个未知量的线性方程组，由它的系数$a_{i,j}$组成的$n$阶行列式，叫做方程组的**系数行列式**。

**增广矩阵**就是在系数行列式的右边添上一列，这一列是线性方程组的等号右边的值。

下面三种变换成为矩阵的**初等行变换**：

1. 换位变换：对调第$i$行与第$j$行$a_i↔a_j$
2. 数乘变换：将$i$行乘上不为0的数$r_i×=k$
3. 倍加变换：将j行的k倍加到$i$行上$a_i+=k⋅a_j$

如同一次方程的同解变形，经过初等行变换后的矩阵所对应的线性方程组也与原方程组同解。这也是高斯消元的核心。

## 高斯消元法

### 思路

对于一个线性方程组，将其增广矩阵，通过行的初等行变换，化为**行最简形矩阵** ，则以后者为增广矩阵的线性方程组与原方程组同解。

行最简形矩阵是一种**行阶梯型矩阵**。如下图是一个行阶梯形矩阵，其代表的方程组中，每个方程的第一个未知量称为**主元**，其余变量叫做**自由元**。

{% asset_img 行阶梯形矩阵.png 行阶梯形矩阵 %}

具体步骤如下：

我们从第一行至最后一行循环，来处理一个$n \times (n+1)$的增广矩阵。对于这个增广矩阵的第$i$行，我们需要在$[i+1,n]$的范围内找到使得$|a_{r,i} |$最大的$r$。交换第$i$行和第$r$行后，将$a_{i,i}$作为主元，通过加减消元，消去$[i+1,n]$的范围内的所有行中的第$i$个系数。

这样，第$i$行中除最后一项外，具有$n - i + 1$个非零项。接下来我们进行后向回代：通过只有一项的第$n$行，解出$x_{n}$。$i$自$n - 1$至$1$循环，对于第$i$行，通过代入消元，消去所有$x_{j}|j > i$，从而解出$x_i$的值。

注意到在消元过程中，我们总是通过行交换操作，选择主元系数绝对值最大的行。这种方法叫做列主元法，因为每一个其他式子的该项系数$a_{j,k} -= \frac{a_{j, i}}{a_{i, i}} \times a_{i, k}$，$a_{i, i}$越大，$a_{j, k}$损失的精度一定程度上就越少。

### 解的判断

对于最简阶梯矩阵，我们讨论解的情况：

若存在一行，其前$n$项均为0而第$i+1$项不为0，意味着出现了$0=1$的情况，矛盾故无解；

当方程有解时，$自由元的个数=未知量个数-最简阶梯矩阵的秩$。若$自由元个数=0$，则具有唯一解；若$自由元个数>0$，则有无穷多解。

事实上，$最简阶梯矩阵的秩$意味着非零行数。若存在一零行，意味着出现方程$0=0$的情况，没有提供更多有效信息，可以不必考虑。而非零行均含有互不相同的唯一主元，故非零行数就是被约束的主元数量。未知量个数减去被约束的主元数量，即为不被约束，可以取任意值的自由元数量。

### 实现

以[P3389 【模板】高斯消元法](https://www.luogu.com.cn/problem/P3389)为例。

```c++
#include <iostream>
#include <cstdio>
#include <cmath>

using namespace std;

const double EPS = 1e-7;
const int MAXN = 105;
double a[MAXN][MAXN];
int main(){
	int n; scanf("%d", &n);
	for(int i = 0; i < n; i++){
		for(int j = 0; j < n + 1; j++){
			scanf("%lf", &a[i][j]);
		}
	}
	for(int i = 0; i < n; i++){ // 消元
		int r = i; // 主元所在行
		for(int j = i + 1; j < n; j++){
			if(fabs(a[j][i]) > fabs(a[r][i])){ // 找到第i项绝对值最大的行
				r = j;
			} 
		}
		if(r != i){ // 交换
			swap(a[i], a[r]);
		}
		if(fabs(a[i][i]) < EPS){ // 考虑到精度误差，用EPS代替0
			printf("No Solution\n"); // 无唯一解
			return 0;
		}
		for(int j = i + 1; j < n; j++){
			double d = a[j][i] / a[i][i];
			for(int k = i; k < n + 1; k++){
				a[j][k] -= a[i][k] * d; // 用主元所在行将第i项消成0
			}
		}
	}
	for(int i = n - 1; i >= 0; i--){ // 回代
		for(int j = i + 1; j < n; j++){
			a[i][n] -= a[i][j] * a[j][n];
		}
		a[i][n] /= a[i][i];
	}
	for(int i = 0; i < n; i++){
		printf("%.2lf\n", a[i][n]);
	}
	return 0;
}
```

## 高斯-约旦消元法

## 思路

相对于传统的高斯消元法，高斯-约旦消元法最后得到的线性方程组更容易求解，省略了后向回代的过程，因而实现相对简单。并具有精度更高的优点，不过此算法的效率较低。

具体步骤如下：

我们从第一行至最后一行循环，来处理一个$n \times (n+1)$的增广矩阵。对于这个增广矩阵的第$i$行，我们需要在$[i+1,n]$的范围内找到使得$|a_{r,i} |$最大的$r$。交换第$i$行和第$r$行后，将$a_{i,i}$作为主元，通过加减消元，消去**$[1,n]$**的范围内的所有行中的第$i$个系数。

也就是说，其消元过程基本与高斯消元法无异，唯独我们加减消元时对于主元$a_{i,i}$消去的范围是$[1,n]$，而不是$[i+1,n]$。这样，第$i$行中除最后一项外，具有$1$个非零项，直接解出$x_i$即可。

## 实现

仍以[P3389 【模板】高斯消元法](https://www.luogu.com.cn/problem/P3389)为例。

```c++
#include <iostream>
#include <cstdio>
#include <cmath>

using namespace std;

const double EPS = 1e-7;
const int MAXN = 105;
double a[MAXN][MAXN];
int main(){
	int n; scanf("%d", &n);
	for(int i = 0; i < n; i++){
		for(int j = 0; j < n + 1; j++){
			scanf("%lf", &a[i][j]);
		}
	}
	for(int i = 0; i < n; i++){ // 消元
		int r = i; // 主元所在行
		for(int j = i + 1; j < n; j++){
			if(fabs(a[j][i]) > fabs(a[r][i])){ // 找到第i项绝对值最大的行
				r = j;
			} 
		}
		if(r != i){ // 交换
			swap(a[i], a[r]);
		}
		if(fabs(a[i][i]) < EPS){ // 考虑到精度误差，用EPS代替0
			printf("No Solution\n"); // 无唯一解
			return 0;
		}
		for(int j = 0; j < n; j++){
			if(j == i) continue;
			double d = a[j][i] / a[i][i];
			for(int k = i; k < n + 1; k++){
				a[j][k] -= a[i][k] * d; // 用主元所在行将第i项消成0
			}
		}
	}
	for(int i = 0; i < n; i++){
		printf("%.2lf\n", a[i][n] / a[i][i]);
	}
	return 0;
}
```



## 注释与参考

1. [https://www.jvruo.com/archives/655/#线性方程组和增广矩阵](https://www.jvruo.com/archives/655/#线性方程组和增广矩阵)
2. 梁霄老师 线性代数.pptx

